## Урок 1. Общие сведения об алгоритмах и структурах данных
>Алгоритмические задачи их решение позволяют немного по другому смотреть на то с чем работаем и глубже погружаться в инструменты с которыми мы ежедневно работаем.

С алгоритмами мы постоянно сталкиваемся в виде методов

**n** - это входные данные, чем больше n тем больше действий

Что-бы высчитывать сложность алгоритмов,
мы будем брать функцию и подвязывать к понятию асимптотическая сложность.

**О большая big-O**:
асимптотическая сложность читается как:

O(n) - о большая от n

O(log n) - о большая от log n

**Асимптотическая сложность** выражающая то самое отношение между количеством действий
с ростом числа входных данных,
поможет нам понять какова сложность алгоритма, насколько один код хуже второго.

>Сложность алгоритма влияет на время выполнения и расход памяти.

>Сложность алгоритма вычисляется из соотношения действий и соотношения 
количества входных данных с течением времени.

#### Виды сложностей из графика: (рис. 1Все сложности на графике)

O(log n) — логарифмическая сложность

O(1) - алгоритм выполняется за постоянное/константное время

O(n) — линейная сложность

O(n log n) - квазилинейная сложность

O(n^2) - полиномиальная сложность

O(2^n) - экспонинцеальная сложность

O(n!) - фактоиальная сложность

#### Где могут появиться эти сложности:

Алгоритмы сортировки:
O(log n) — логарифмическая сложность
O(n) — линейная сложность

Тоже в алгоритмах сортировки, и в собственных алгоритмах реализованых мною:
O(n^2) - полиномиальная сложность
O(n log n) - квазилинейная сложность

В деревьях:
O(2^n) - экспонинцеальная сложность

Полный перебор: (узкоспециализированные задачи)
O(n!) - фактоиальная сложность


#### Подсчет O большого:

1. первый пример

тайминг видео, Урок 1. Общие сведения об алгоритмах и структурах данных - 1:01 мин

в примере кода lesson1 -> Rule123.java

```markdown
// O(1) + O(1) + O(1) + O(1) + O(4n - 3)

// O(4n - 3)

// O(4n)

// O(n)
```

>подсчет происходит по принципу сколько раз, n это будет количество раз, каждого действия,
будь это инициализация переменной, проход цикла, вывод на экран, сравнение, присваивание
при выборе из нескольких равнозначно стоящих относительно друг друга сложностей, выбираем самую сложную
сокращаем: отбрасываем константы, проход по элементам массива всреднем n раз получается, линейная сложность
при определении сложности смотрим что из себя представляет данный цикл, смотрим на побочные условия внитри тела цикла которые напрямую могут повлиять на количество исполнений
например for (int i = 1; i < n; i*=2) //O(logn) , увеличение скорости в данном случае происходит в геометрической прогрессии по условию i *= 2



2. второй пример

тайминг видео, Урок 1. Общие сведения об алгоритмах и структурах данных - 1:14 мин
в примере кода lesson1 -> Rule4.java
два цикла O(n), один вложен в другой поэтому O(n^2) полиномиальная сложность
```markdown
//O(n)*O(n)=O(n^2)
```

3. третий пример:

тайминг видео, Урок 1. Общие сведения об алгоритмах и структурах данных - 1:15:30 мин

```markdown
лучший
худший
средний случаи
```



четвертый пример:
тайминг видео, Урок 1. Общие сведения об алгоритмах и структурах данных - 1:23:00 мин
```markdown
Логарифмическая сложность
```

>По таблице временной сложности сортировок(рис. 4Сложности сортировок), ориентируемся на средний случай.